
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>recommenders.evaluation.python_evaluation &#8212; &lt;h1 style=&#34;font-size:2em;text-align:center;color:#FF5733&#34;&gt;Recommenders&lt;/h1&gt;</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/tabs.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <link rel="canonical" href="https://microsoft.github.io/genalog/_modules/recommenders/evaluation/python_evaluation.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
      
      
      <h1 class="site-logo" id="site-title"><h1 style="font-size:2em;text-align:center;color:#FF5733">Recommenders</h1></h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/microsoft/genalog"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/microsoft/genalog/issues/new?title=Issue%20on%20page%20%2F_modules/recommenders/evaluation/python_evaluation.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <h1>Source code for recommenders.evaluation.python_evaluation</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c1"># Licensed under the MIT License.</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">mean_squared_error</span><span class="p">,</span>
    <span class="n">mean_absolute_error</span><span class="p">,</span>
    <span class="n">r2_score</span><span class="p">,</span>
    <span class="n">explained_variance_score</span><span class="p">,</span>
    <span class="n">roc_auc_score</span><span class="p">,</span>
    <span class="n">log_loss</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">recommenders.utils.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
    <span class="n">DEFAULT_RELEVANCE_COL</span><span class="p">,</span>
    <span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
    <span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
    <span class="n">DEFAULT_K</span><span class="p">,</span>
    <span class="n">DEFAULT_THRESHOLD</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">recommenders.datasets.pandas_df_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">has_columns</span><span class="p">,</span>
    <span class="n">has_same_base_dtype</span><span class="p">,</span>
    <span class="n">lru_cache_df</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_column_dtypes</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks columns of DataFrame inputs</span>

<span class="sd">    This includes the checks on:</span>

<span class="sd">    * whether the input columns exist in the input DataFrames</span>
<span class="sd">    * whether the data types of col_user as well as col_item are matched in the two input DataFrames.</span>

<span class="sd">    Args:</span>
<span class="sd">        func (function): function that will be wrapped</span>

<span class="sd">    Returns:</span>
<span class="sd">        function: Wrapper function for checking dtypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">check_column_dtypes_wrapper</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check columns of DataFrame inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            rating_true (pandas.DataFrame): True data</span>
<span class="sd">            rating_pred (pandas.DataFrame): Predicted data</span>
<span class="sd">            col_user (str): column name for user</span>
<span class="sd">            col_item (str): column name for item</span>
<span class="sd">            col_rating (str): column name for rating</span>
<span class="sd">            col_prediction (str): column name for prediction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_columns</span><span class="p">(</span><span class="n">rating_true</span><span class="p">,</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">,</span> <span class="n">col_rating</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing columns in true rating DataFrame&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_columns</span><span class="p">(</span><span class="n">rating_pred</span><span class="p">,</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">,</span> <span class="n">col_prediction</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing columns in predicted rating DataFrame&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_same_base_dtype</span><span class="p">(</span>
            <span class="n">rating_true</span><span class="p">,</span> <span class="n">rating_pred</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns in provided DataFrames are not the same datatype&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span><span class="p">(</span>
            <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
            <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
            <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
            <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
            <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
            <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">check_column_dtypes_wrapper</span>


<div class="viewcode-block" id="merge_rating_true_pred"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.merge_rating_true_pred">[docs]</a><span class="nd">@_check_column_dtypes</span>
<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">merge_rating_true_pred</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Join truth and prediction data frames on userID and itemID and return the true</span>
<span class="sd">    and predicted rated with the correct index.</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True data</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted data</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Array with the true ratings</span>
<span class="sd">        numpy.ndarray: Array with the predicted ratings</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pd.merge will apply suffixes to columns which have the same name across both dataframes</span>
    <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_true&quot;</span><span class="p">,</span> <span class="s2">&quot;_pred&quot;</span><span class="p">]</span>
    <span class="n">rating_true_pred</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="p">,</span> <span class="n">rating_pred</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">],</span> <span class="n">suffixes</span><span class="o">=</span><span class="n">suffixes</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">col_rating</span> <span class="ow">in</span> <span class="n">rating_pred</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">col_rating</span> <span class="o">=</span> <span class="n">col_rating</span> <span class="o">+</span> <span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">col_prediction</span> <span class="ow">in</span> <span class="n">rating_true</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">col_prediction</span> <span class="o">=</span> <span class="n">col_prediction</span> <span class="o">+</span> <span class="n">suffixes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rating_true_pred</span><span class="p">[</span><span class="n">col_rating</span><span class="p">],</span> <span class="n">rating_true_pred</span><span class="p">[</span><span class="n">col_prediction</span><span class="p">]</span></div>


<div class="viewcode-block" id="rmse"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.rmse">[docs]</a><span class="k">def</span> <span class="nf">rmse</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate Root Mean Squared Error</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True data. There should be no duplicate (userID, itemID) pairs</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted data. There should be no duplicate (userID, itemID) pairs</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Root mean squared error</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span> <span class="o">=</span> <span class="n">merge_rating_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span></div>


<div class="viewcode-block" id="mae"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.mae">[docs]</a><span class="k">def</span> <span class="nf">mae</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate Mean Absolute Error.</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True data. There should be no duplicate (userID, itemID) pairs</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted data. There should be no duplicate (userID, itemID) pairs</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Mean Absolute Error.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span> <span class="o">=</span> <span class="n">merge_rating_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span></div>


<div class="viewcode-block" id="rsquared"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.rsquared">[docs]</a><span class="k">def</span> <span class="nf">rsquared</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate R squared</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True data. There should be no duplicate (userID, itemID) pairs</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted data. There should be no duplicate (userID, itemID) pairs</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: R squared (min=0, max=1).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span> <span class="o">=</span> <span class="n">merge_rating_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span></div>


<div class="viewcode-block" id="exp_var"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.exp_var">[docs]</a><span class="k">def</span> <span class="nf">exp_var</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate explained variance.</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True data. There should be no duplicate (userID, itemID) pairs</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted data. There should be no duplicate (userID, itemID) pairs</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Explained variance (min=0, max=1).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span> <span class="o">=</span> <span class="n">merge_rating_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">explained_variance_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span></div>


<div class="viewcode-block" id="auc"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.auc">[docs]</a><span class="k">def</span> <span class="nf">auc</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Area-Under-Curve metric for implicit feedback typed</span>
<span class="sd">    recommender, where rating is binary and prediction is float number ranging</span>
<span class="sd">    from 0 to 1.</span>

<span class="sd">    https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve</span>

<span class="sd">    Note:</span>
<span class="sd">        The evaluation does not require a leave-one-out scenario.</span>
<span class="sd">        This metric does not calculate group-based AUC which considers the AUC scores</span>
<span class="sd">        averaged across users. It is also not limited to k. Instead, it calculates the</span>
<span class="sd">        scores on the entire prediction results regardless the users.</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True data</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted data</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: auc_score (min=0, max=1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span> <span class="o">=</span> <span class="n">merge_rating_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span></div>


<div class="viewcode-block" id="logloss"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.logloss">[docs]</a><span class="k">def</span> <span class="nf">logloss</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the logloss metric for implicit feedback typed</span>
<span class="sd">    recommender, where rating is binary and prediction is float number ranging</span>
<span class="sd">    from 0 to 1.</span>

<span class="sd">    https://en.wikipedia.org/wiki/Loss_functions_for_classification#Cross_entropy_loss_(Log_Loss)</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True data</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted data</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: log_loss_score (min=-inf, max=inf)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span> <span class="o">=</span> <span class="n">merge_rating_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">log_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span></div>


<div class="viewcode-block" id="merge_ranking_true_pred"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.merge_ranking_true_pred">[docs]</a><span class="nd">@_check_column_dtypes</span>
<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">merge_ranking_true_pred</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="p">,</span>
    <span class="n">col_item</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="p">,</span>
    <span class="n">relevancy_method</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="n">DEFAULT_K</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="n">DEFAULT_THRESHOLD</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filter truth and prediction data frames on common users</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True DataFrame</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted DataFrame</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>
<span class="sd">        relevancy_method (str): method for determining relevancy [&#39;top_k&#39;, &#39;by_threshold&#39;, None]. None means that the</span>
<span class="sd">            top k items are directly provided, so there is no need to compute the relevancy operation.</span>
<span class="sd">        k (int): number of top k items per user (optional)</span>
<span class="sd">        threshold (float): threshold of top items per user (optional)</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame, pandas.DataFrame, int: DataFrame of recommendation hits, sorted by `col_user` and `rank`</span>
<span class="sd">        DataFrame of hit counts vs actual relevant items per user number of unique user ids</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure the prediction and true data frames have the same set of users</span>
    <span class="n">common_users</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rating_true</span><span class="p">[</span><span class="n">col_user</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rating_pred</span><span class="p">[</span><span class="n">col_user</span><span class="p">]))</span>
    <span class="n">rating_true_common</span> <span class="o">=</span> <span class="n">rating_true</span><span class="p">[</span><span class="n">rating_true</span><span class="p">[</span><span class="n">col_user</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">common_users</span><span class="p">)]</span>
    <span class="n">rating_pred_common</span> <span class="o">=</span> <span class="n">rating_pred</span><span class="p">[</span><span class="n">rating_pred</span><span class="p">[</span><span class="n">col_user</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">common_users</span><span class="p">)]</span>
    <span class="n">n_users</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_users</span><span class="p">)</span>

    <span class="c1"># Return hit items in prediction data frame with ranking information. This is used for calculating NDCG and MAP.</span>
    <span class="c1"># Use first to generate unique ranking values for each item. This is to align with the implementation in</span>
    <span class="c1"># Spark evaluation metrics, where index of each recommended items (the indices are unique to items) is used</span>
    <span class="c1"># to calculate penalized precision of the ordered items.</span>
    <span class="k">if</span> <span class="n">relevancy_method</span> <span class="o">==</span> <span class="s2">&quot;top_k&quot;</span><span class="p">:</span>
        <span class="n">top_k</span> <span class="o">=</span> <span class="n">k</span>
    <span class="k">elif</span> <span class="n">relevancy_method</span> <span class="o">==</span> <span class="s2">&quot;by_threshold&quot;</span><span class="p">:</span>
        <span class="n">top_k</span> <span class="o">=</span> <span class="n">threshold</span>
    <span class="k">elif</span> <span class="n">relevancy_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">top_k</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Invalid relevancy_method&quot;</span><span class="p">)</span>
    <span class="n">df_hit</span> <span class="o">=</span> <span class="n">get_top_k_items</span><span class="p">(</span>
        <span class="n">dataframe</span><span class="o">=</span><span class="n">rating_pred_common</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">top_k</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">df_hit</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_hit</span><span class="p">,</span> <span class="n">rating_true_common</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">])[</span>
        <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">,</span> <span class="s2">&quot;rank&quot;</span><span class="p">]</span>
    <span class="p">]</span>

    <span class="c1"># count the number of hits vs actual relevant items per user</span>
    <span class="n">df_hit_count</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">df_hit</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_user</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="n">col_user</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;hit&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">}),</span>
        <span class="n">rating_true_common</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_user</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="n">col_user</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;actual&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">}</span>
        <span class="p">),</span>
        <span class="n">on</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_hit</span><span class="p">,</span> <span class="n">df_hit_count</span><span class="p">,</span> <span class="n">n_users</span></div>


<div class="viewcode-block" id="precision_at_k"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.precision_at_k">[docs]</a><span class="k">def</span> <span class="nf">precision_at_k</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
    <span class="n">relevancy_method</span><span class="o">=</span><span class="s2">&quot;top_k&quot;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="n">DEFAULT_K</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="n">DEFAULT_THRESHOLD</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Precision at K.</span>

<span class="sd">    Note:</span>
<span class="sd">        We use the same formula to calculate precision@k as that in Spark.</span>
<span class="sd">        More details can be found at</span>
<span class="sd">        http://spark.apache.org/docs/2.1.1/api/python/pyspark.mllib.html#pyspark.mllib.evaluation.RankingMetrics.precisionAt</span>
<span class="sd">        In particular, the maximum achievable precision may be &lt; 1, if the number of items for a</span>
<span class="sd">        user in rating_pred is less than k.</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True DataFrame</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted DataFrame</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>
<span class="sd">        relevancy_method (str): method for determining relevancy [&#39;top_k&#39;, &#39;by_threshold&#39;, None]. None means that the</span>
<span class="sd">            top k items are directly provided, so there is no need to compute the relevancy operation.</span>
<span class="sd">        k (int): number of top k items per user</span>
<span class="sd">        threshold (float): threshold of top items per user (optional)</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: precision at k (min=0, max=1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_hit</span><span class="p">,</span> <span class="n">df_hit_count</span><span class="p">,</span> <span class="n">n_users</span> <span class="o">=</span> <span class="n">merge_ranking_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
        <span class="n">relevancy_method</span><span class="o">=</span><span class="n">relevancy_method</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">df_hit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">df_hit_count</span><span class="p">[</span><span class="s2">&quot;hit&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_users</span></div>


<div class="viewcode-block" id="recall_at_k"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.recall_at_k">[docs]</a><span class="k">def</span> <span class="nf">recall_at_k</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
    <span class="n">relevancy_method</span><span class="o">=</span><span class="s2">&quot;top_k&quot;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="n">DEFAULT_K</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="n">DEFAULT_THRESHOLD</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recall at K.</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True DataFrame</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted DataFrame</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>
<span class="sd">        relevancy_method (str): method for determining relevancy [&#39;top_k&#39;, &#39;by_threshold&#39;, None]. None means that the</span>
<span class="sd">            top k items are directly provided, so there is no need to compute the relevancy operation.</span>
<span class="sd">        k (int): number of top k items per user</span>
<span class="sd">        threshold (float): threshold of top items per user (optional)</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: recall at k (min=0, max=1). The maximum value is 1 even when fewer than</span>
<span class="sd">        k items exist for a user in rating_true.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_hit</span><span class="p">,</span> <span class="n">df_hit_count</span><span class="p">,</span> <span class="n">n_users</span> <span class="o">=</span> <span class="n">merge_ranking_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
        <span class="n">relevancy_method</span><span class="o">=</span><span class="n">relevancy_method</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">df_hit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">df_hit_count</span><span class="p">[</span><span class="s2">&quot;hit&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df_hit_count</span><span class="p">[</span><span class="s2">&quot;actual&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_users</span></div>


<div class="viewcode-block" id="ndcg_at_k"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.ndcg_at_k">[docs]</a><span class="k">def</span> <span class="nf">ndcg_at_k</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
    <span class="n">relevancy_method</span><span class="o">=</span><span class="s2">&quot;top_k&quot;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="n">DEFAULT_K</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="n">DEFAULT_THRESHOLD</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalized Discounted Cumulative Gain (nDCG).</span>

<span class="sd">    Info: https://en.wikipedia.org/wiki/Discounted_cumulative_gain</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True DataFrame</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted DataFrame</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>
<span class="sd">        relevancy_method (str): method for determining relevancy [&#39;top_k&#39;, &#39;by_threshold&#39;, None]. None means that the</span>
<span class="sd">            top k items are directly provided, so there is no need to compute the relevancy operation.</span>
<span class="sd">        k (int): number of top k items per user</span>
<span class="sd">        threshold (float): threshold of top items per user (optional)</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: nDCG at k (min=0, max=1).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_hit</span><span class="p">,</span> <span class="n">df_hit_count</span><span class="p">,</span> <span class="n">n_users</span> <span class="o">=</span> <span class="n">merge_ranking_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
        <span class="n">relevancy_method</span><span class="o">=</span><span class="n">relevancy_method</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">df_hit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="c1"># calculate discounted gain for hit items</span>
    <span class="n">df_dcg</span> <span class="o">=</span> <span class="n">df_hit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># relevance in this case is always 1</span>
    <span class="n">df_dcg</span><span class="p">[</span><span class="s2">&quot;dcg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">df_dcg</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">])</span>
    <span class="c1"># sum up discount gained to get discount cumulative gain</span>
    <span class="n">df_dcg</span> <span class="o">=</span> <span class="n">df_dcg</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_user</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;dcg&quot;</span><span class="p">:</span> <span class="s2">&quot;sum&quot;</span><span class="p">})</span>
    <span class="c1"># calculate ideal discounted cumulative gain</span>
    <span class="n">df_ndcg</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_dcg</span><span class="p">,</span> <span class="n">df_hit_count</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">])</span>
    <span class="n">df_ndcg</span><span class="p">[</span><span class="s2">&quot;idcg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_ndcg</span><span class="p">[</span><span class="s2">&quot;actual&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">)</span>

    <span class="c1"># DCG over IDCG is the normalized DCG</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">df_ndcg</span><span class="p">[</span><span class="s2">&quot;dcg&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df_ndcg</span><span class="p">[</span><span class="s2">&quot;idcg&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_users</span></div>


<div class="viewcode-block" id="map_at_k"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.map_at_k">[docs]</a><span class="k">def</span> <span class="nf">map_at_k</span><span class="p">(</span>
    <span class="n">rating_true</span><span class="p">,</span>
    <span class="n">rating_pred</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span>
    <span class="n">col_prediction</span><span class="o">=</span><span class="n">DEFAULT_PREDICTION_COL</span><span class="p">,</span>
    <span class="n">relevancy_method</span><span class="o">=</span><span class="s2">&quot;top_k&quot;</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="n">DEFAULT_K</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="n">DEFAULT_THRESHOLD</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mean Average Precision at k</span>

<span class="sd">    The implementation of MAP is referenced from Spark MLlib evaluation metrics.</span>
<span class="sd">    https://spark.apache.org/docs/2.3.0/mllib-evaluation-metrics.html#ranking-systems</span>

<span class="sd">    A good reference can be found at:</span>
<span class="sd">    http://web.stanford.edu/class/cs276/handouts/EvaluationNew-handout-6-per.pdf</span>

<span class="sd">    Note:</span>
<span class="sd">        1. The evaluation function is named as &#39;MAP is at k&#39; because the evaluation class takes top k items for</span>
<span class="sd">        the prediction items. The naming is different from Spark.</span>

<span class="sd">        2. The MAP is meant to calculate Avg. Precision for the relevant items, so it is normalized by the number of</span>
<span class="sd">        relevant items in the ground truth data, instead of k.</span>

<span class="sd">    Args:</span>
<span class="sd">        rating_true (pandas.DataFrame): True DataFrame</span>
<span class="sd">        rating_pred (pandas.DataFrame): Predicted DataFrame</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_item (str): column name for item</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        col_prediction (str): column name for prediction</span>
<span class="sd">        relevancy_method (str): method for determining relevancy [&#39;top_k&#39;, &#39;by_threshold&#39;, None]. None means that the</span>
<span class="sd">            top k items are directly provided, so there is no need to compute the relevancy operation.</span>
<span class="sd">        k (int): number of top k items per user</span>
<span class="sd">        threshold (float): threshold of top items per user (optional)</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: MAP at k (min=0, max=1).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_hit</span><span class="p">,</span> <span class="n">df_hit_count</span><span class="p">,</span> <span class="n">n_users</span> <span class="o">=</span> <span class="n">merge_ranking_true_pred</span><span class="p">(</span>
        <span class="n">rating_true</span><span class="o">=</span><span class="n">rating_true</span><span class="p">,</span>
        <span class="n">rating_pred</span><span class="o">=</span><span class="n">rating_pred</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_rating</span><span class="o">=</span><span class="n">col_rating</span><span class="p">,</span>
        <span class="n">col_prediction</span><span class="o">=</span><span class="n">col_prediction</span><span class="p">,</span>
        <span class="n">relevancy_method</span><span class="o">=</span><span class="n">relevancy_method</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">df_hit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="c1"># calculate reciprocal rank of items for each user and sum them up</span>
    <span class="n">df_hit_sorted</span> <span class="o">=</span> <span class="n">df_hit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">df_hit_sorted</span><span class="p">[</span><span class="s2">&quot;rr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_hit_sorted</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_user</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">df_hit_sorted</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span>
    <span class="n">df_hit_sorted</span> <span class="o">=</span> <span class="n">df_hit_sorted</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_user</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;rr&quot;</span><span class="p">:</span> <span class="s2">&quot;sum&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="n">df_merge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_hit_sorted</span><span class="p">,</span> <span class="n">df_hit_count</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">col_user</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">df_merge</span><span class="p">[</span><span class="s2">&quot;rr&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df_merge</span><span class="p">[</span><span class="s2">&quot;actual&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_users</span></div>


<div class="viewcode-block" id="get_top_k_items"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.get_top_k_items">[docs]</a><span class="k">def</span> <span class="nf">get_top_k_items</span><span class="p">(</span>
    <span class="n">dataframe</span><span class="p">,</span> <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span> <span class="n">col_rating</span><span class="o">=</span><span class="n">DEFAULT_RATING_COL</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">DEFAULT_K</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the input customer-item-rating tuple in the format of Pandas</span>
<span class="sd">    DataFrame, output a Pandas DataFrame in the dense format of top k items</span>
<span class="sd">    for each user.</span>

<span class="sd">    Note:</span>
<span class="sd">        If it is implicit rating, just append a column of constants to be</span>
<span class="sd">        ratings.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataframe (pandas.DataFrame): DataFrame of rating data (in the format</span>
<span class="sd">        customerID-itemID-rating)</span>
<span class="sd">        col_user (str): column name for user</span>
<span class="sd">        col_rating (str): column name for rating</span>
<span class="sd">        k (int or None): number of items for each user; None means that the input has already been</span>
<span class="sd">        filtered out top k items and sorted by ratings and there is no need to do that again.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: DataFrame of top k items for each user, sorted by `col_user` and `rank`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sort dataframe by col_user and (top k) col_rating</span>
    <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">top_k_items</span> <span class="o">=</span> <span class="n">dataframe</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">top_k_items</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">dataframe</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_user</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">col_rating</span><span class="p">))</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># Add ranks</span>
    <span class="n">top_k_items</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_k_items</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_user</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">top_k_items</span></div>


<span class="sd">&quot;&quot;&quot;Function name and function mapper.</span>
<span class="sd">Useful when we have to serialize evaluation metric names</span>
<span class="sd">and call the functions based on deserialized names&quot;&quot;&quot;</span>
<span class="n">metrics</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">rmse</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">rmse</span><span class="p">,</span>
    <span class="n">mae</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">mae</span><span class="p">,</span>
    <span class="n">rsquared</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">rsquared</span><span class="p">,</span>
    <span class="n">exp_var</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">exp_var</span><span class="p">,</span>
    <span class="n">precision_at_k</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">precision_at_k</span><span class="p">,</span>
    <span class="n">recall_at_k</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">recall_at_k</span><span class="p">,</span>
    <span class="n">ndcg_at_k</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">ndcg_at_k</span><span class="p">,</span>
    <span class="n">map_at_k</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">map_at_k</span><span class="p">,</span>
<span class="p">}</span>


<span class="c1"># diversity metrics</span>
<span class="k">def</span> <span class="nf">_check_column_dtypes_diversity_serendipity</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks columns of DataFrame inputs</span>

<span class="sd">    This includes the checks on:</span>

<span class="sd">    * whether the input columns exist in the input DataFrames</span>
<span class="sd">    * whether the data types of col_user as well as col_item are matched in the two input DataFrames.</span>
<span class="sd">    * whether reco_df contains any user_item pairs that are already shown in train_df</span>
<span class="sd">    * check relevance column in reco_df</span>
<span class="sd">    * check column names in item_feature_df</span>

<span class="sd">    Args:</span>
<span class="sd">        func (function): function that will be wrapped</span>

<span class="sd">    Returns:</span>
<span class="sd">        function: Wrapper function for checking dtypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">check_column_dtypes_diversity_serendipity_wrapper</span><span class="p">(</span>
        <span class="n">train_df</span><span class="p">,</span>
        <span class="n">reco_df</span><span class="p">,</span>
        <span class="n">item_feature_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
        <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
        <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
        <span class="n">col_relevance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check columns of DataFrame inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">                have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">            reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">                col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">            item_feature_df (pandas.DataFrame): (Optional) It is required only when item_sim_measure=&#39;item_feature_vector&#39;.</span>
<span class="sd">                It contains two columns: col_item and features (a feature vector).</span>
<span class="sd">            item_sim_measure (str): (Optional) This column indicates which item similarity measure to be used.</span>
<span class="sd">                Available measures include item_cooccurrence_count (default choice) and item_feature_vector.</span>
<span class="sd">            col_item_features (str): item feature column name.</span>
<span class="sd">            col_user (str): User id column name.</span>
<span class="sd">            col_item (str): Item id column name.</span>
<span class="sd">            col_sim (str): This column indicates the column name for item similarity.</span>
<span class="sd">            col_relevance (str): This column indicates whether the recommended item is actually</span>
<span class="sd">                relevant to the user or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_columns</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing columns in train_df DataFrame&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_columns</span><span class="p">(</span><span class="n">reco_df</span><span class="p">,</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing columns in reco_df DataFrame&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_same_base_dtype</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="n">reco_df</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns in provided DataFrames are not the same datatype&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col_relevance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col_relevance</span> <span class="o">=</span> <span class="n">DEFAULT_RELEVANCE_COL</span>
            <span class="c1"># relevance term, default is 1 (relevant) for all</span>
            <span class="n">reco_df</span> <span class="o">=</span> <span class="n">reco_df</span><span class="p">[[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]]</span>
            <span class="n">reco_df</span><span class="p">[</span><span class="n">col_relevance</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col_relevance</span> <span class="o">=</span> <span class="n">col_relevance</span>
            <span class="n">reco_df</span> <span class="o">=</span> <span class="n">reco_df</span><span class="p">[[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">,</span> <span class="n">col_relevance</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="p">{</span><span class="n">col_relevance</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">item_sim_measure</span> <span class="o">==</span> <span class="s2">&quot;item_feature_vector&quot;</span><span class="p">:</span>
            <span class="n">required_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_item</span><span class="p">,</span> <span class="n">col_item_features</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">item_feature_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">has_columns</span><span class="p">(</span><span class="n">item_feature_df</span><span class="p">,</span> <span class="n">required_columns</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing columns in item_feature_df DataFrame&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;item_feature_df not specified! item_feature_df must be provided &quot;</span>
                    <span class="s2">&quot;if choosing to use item_feature_vector to calculate item similarity. &quot;</span>
                    <span class="s2">&quot;item_feature_df should have columns: &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">required_columns</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="c1"># check if reco_df contains any user_item pairs that are already shown in train_df</span>
        <span class="n">count_intersection</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">train_df</span><span class="p">,</span> <span class="n">reco_df</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count_intersection</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;reco_df should not contain any user_item pairs that are already shown in train_df&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span><span class="p">(</span>
            <span class="n">train_df</span><span class="o">=</span><span class="n">train_df</span><span class="p">,</span>
            <span class="n">reco_df</span><span class="o">=</span><span class="n">reco_df</span><span class="p">,</span>
            <span class="n">item_feature_df</span><span class="o">=</span><span class="n">item_feature_df</span><span class="p">,</span>
            <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">item_sim_measure</span><span class="p">,</span>
            <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
            <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
            <span class="n">col_sim</span><span class="o">=</span><span class="n">col_sim</span><span class="p">,</span>
            <span class="n">col_relevance</span><span class="o">=</span><span class="n">col_relevance</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">check_column_dtypes_diversity_serendipity_wrapper</span>


<span class="k">def</span> <span class="nf">_check_column_dtypes_novelty_coverage</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks columns of DataFrame inputs</span>

<span class="sd">    This includes the checks on:</span>

<span class="sd">    * whether the input columns exist in the input DataFrames</span>
<span class="sd">    * whether the data types of col_user as well as col_item are matched in the two input DataFrames.</span>
<span class="sd">    * whether reco_df contains any user_item pairs that are already shown in train_df</span>

<span class="sd">    Args:</span>
<span class="sd">        func (function): function that will be wrapped</span>

<span class="sd">    Returns:</span>
<span class="sd">        function: Wrapper function for checking dtypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">check_column_dtypes_novelty_coverage_wrapper</span><span class="p">(</span>
        <span class="n">train_df</span><span class="p">,</span>
        <span class="n">reco_df</span><span class="p">,</span>
        <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
        <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check columns of DataFrame inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">                have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">                Interaction here follows the *item choice model* from Castells et al.</span>
<span class="sd">            reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">                col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">            col_user (str): User id column name.</span>
<span class="sd">            col_item (str): Item id column name.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_columns</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing columns in train_df DataFrame&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_columns</span><span class="p">(</span><span class="n">reco_df</span><span class="p">,</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing columns in reco_df DataFrame&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_same_base_dtype</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="n">reco_df</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns in provided DataFrames are not the same datatype&quot;</span><span class="p">)</span>

        <span class="n">count_intersection</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">train_df</span><span class="p">,</span> <span class="n">reco_df</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count_intersection</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;reco_df should not contain any user_item pairs that are already shown in train_df&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span><span class="p">(</span>
            <span class="n">train_df</span><span class="o">=</span><span class="n">train_df</span><span class="p">,</span>
            <span class="n">reco_df</span><span class="o">=</span><span class="n">reco_df</span><span class="p">,</span>
            <span class="n">col_user</span><span class="o">=</span><span class="n">col_user</span><span class="p">,</span>
            <span class="n">col_item</span><span class="o">=</span><span class="n">col_item</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">check_column_dtypes_novelty_coverage_wrapper</span>


<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_pairwise_items</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get pairwise combinations of items per user (ignoring duplicate pairs [1,2] == [2,1])&quot;&quot;&quot;</span>
    <span class="n">df_user_i1</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]]</span>
    <span class="n">df_user_i1</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="s2">&quot;i1&quot;</span><span class="p">]</span>

    <span class="n">df_user_i2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]]</span>
    <span class="n">df_user_i2</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">]</span>

    <span class="n">df_user_i1_i2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_user_i1</span><span class="p">,</span> <span class="n">df_user_i2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">])</span>

    <span class="n">df_pairwise_items</span> <span class="o">=</span> <span class="n">df_user_i1_i2</span><span class="p">[(</span><span class="n">df_user_i1_i2</span><span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">df_user_i1_i2</span><span class="p">[</span><span class="s2">&quot;i2&quot;</span><span class="p">])][</span>
        <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">]</span>
    <span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df_pairwise_items</span>


<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_cosine_similarity</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">item_feature_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
    <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
<span class="p">):</span>

    <span class="k">if</span> <span class="n">item_sim_measure</span> <span class="o">==</span> <span class="s2">&quot;item_cooccurrence_count&quot;</span><span class="p">:</span>
        <span class="c1"># calculate item-item similarity based on item co-occurrence count</span>
        <span class="n">df_cosine_similarity</span> <span class="o">=</span> <span class="n">_get_cooccurrence_similarity</span><span class="p">(</span>
            <span class="n">train_df</span><span class="p">,</span> <span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">,</span> <span class="n">col_sim</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">item_sim_measure</span> <span class="o">==</span> <span class="s2">&quot;item_feature_vector&quot;</span><span class="p">:</span>
        <span class="c1"># calculdf_cosine_similarity = ate item-item similarity based on item feature vectors</span>
        <span class="n">df_cosine_similarity</span> <span class="o">=</span> <span class="n">_get_item_feature_similarity</span><span class="p">(</span>
            <span class="n">item_feature_df</span><span class="p">,</span> <span class="n">col_item_features</span><span class="p">,</span> <span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;item_sim_measure not recognized! The available options include &#39;item_cooccurrence_count&#39; and &#39;item_feature_vector&#39;.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df_cosine_similarity</span>


<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_cooccurrence_similarity</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cosine similarity metric from</span>

<span class="sd">    :Citation:</span>

<span class="sd">        Y.C. Zhang, D.Ó. Séaghdha, D. Quercia and T. Jambor, Auralist:</span>
<span class="sd">        introducing serendipity into music recommendation, WSDM 2012</span>

<span class="sd">    The item indexes in the result are such that i1 &lt;= i2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">_get_pairwise_items</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">)</span>
    <span class="n">pairs_count</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">pairs</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()}</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">item_count</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">train_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">col_item</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()}</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">item_count</span><span class="p">[</span><span class="s2">&quot;item_sqrt_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">item_count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="n">item_co_occur</span> <span class="o">=</span> <span class="n">pairs_count</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">item_count</span><span class="p">[[</span><span class="n">col_item</span><span class="p">,</span> <span class="s2">&quot;item_sqrt_count&quot;</span><span class="p">]],</span>
        <span class="n">left_on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">],</span>
        <span class="n">right_on</span><span class="o">=</span><span class="p">[</span><span class="n">col_item</span><span class="p">],</span>
    <span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col_item</span><span class="p">])</span>

    <span class="n">item_co_occur</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;i1_sqrt_count&quot;</span><span class="p">]</span>

    <span class="n">item_co_occur</span> <span class="o">=</span> <span class="n">item_co_occur</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">item_count</span><span class="p">[[</span><span class="n">col_item</span><span class="p">,</span> <span class="s2">&quot;item_sqrt_count&quot;</span><span class="p">]],</span>
        <span class="n">left_on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;i2&quot;</span><span class="p">],</span>
        <span class="n">right_on</span><span class="o">=</span><span class="p">[</span><span class="n">col_item</span><span class="p">],</span>
    <span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col_item</span><span class="p">])</span>
    <span class="n">item_co_occur</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;i1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;i2&quot;</span><span class="p">,</span>
        <span class="s2">&quot;count&quot;</span><span class="p">,</span>
        <span class="s2">&quot;i1_sqrt_count&quot;</span><span class="p">,</span>
        <span class="s2">&quot;i2_sqrt_count&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">item_co_occur</span><span class="p">[</span><span class="n">col_sim</span><span class="p">]</span> <span class="o">=</span> <span class="n">item_co_occur</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span>
        <span class="n">item_co_occur</span><span class="p">[</span><span class="s2">&quot;i1_sqrt_count&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">item_co_occur</span><span class="p">[</span><span class="s2">&quot;i2_sqrt_count&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">df_cosine_similarity</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">item_co_occur</span><span class="p">[[</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">,</span> <span class="n">col_sim</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_cosine_similarity</span>


<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_item_feature_similarity</span><span class="p">(</span>
    <span class="n">item_feature_df</span><span class="p">,</span>
    <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cosine similarity metric based on item feature vectors</span>

<span class="sd">    The item indexes in the result are such that i1 &lt;= i2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df1</span> <span class="o">=</span> <span class="n">item_feature_df</span><span class="p">[[</span><span class="n">col_item</span><span class="p">,</span> <span class="n">col_item_features</span><span class="p">]]</span>
    <span class="n">df1</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;f1&quot;</span><span class="p">]</span>
    <span class="n">df1</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">df2</span> <span class="o">=</span> <span class="n">item_feature_df</span><span class="p">[[</span><span class="n">col_item</span><span class="p">,</span> <span class="n">col_item_features</span><span class="p">]]</span>
    <span class="n">df2</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;i2&quot;</span><span class="p">,</span> <span class="s2">&quot;f2&quot;</span><span class="p">]</span>
    <span class="n">df2</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">df_item_feature_pair</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;i2&quot;</span><span class="p">])]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">df_item_feature_pair</span><span class="p">[</span><span class="n">col_sim</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_item_feature_pair</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">f1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">f2</span><span class="p">))</span>
        <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">f1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">f2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">df_cosine_similarity</span> <span class="o">=</span> <span class="n">df_item_feature_pair</span><span class="p">[[</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">,</span> <span class="n">col_sim</span><span class="p">]]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_cosine_similarity</span>


<span class="c1"># Diversity metrics</span>
<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_intralist_similarity</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">reco_df</span><span class="p">,</span>
    <span class="n">item_feature_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
    <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Intra-list similarity from</span>

<span class="sd">    :Citation:</span>

<span class="sd">        &quot;Improving Recommendation Lists Through Topic Diversification&quot;,</span>
<span class="sd">        Ziegler, McNee, Konstan and Lausen, 2005.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">_get_pairwise_items</span><span class="p">(</span><span class="n">reco_df</span><span class="p">,</span> <span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">)</span>
    <span class="n">similarity_df</span> <span class="o">=</span> <span class="n">_get_cosine_similarity</span><span class="p">(</span>
        <span class="n">train_df</span><span class="p">,</span>
        <span class="n">item_feature_df</span><span class="p">,</span>
        <span class="n">item_sim_measure</span><span class="p">,</span>
        <span class="n">col_item_features</span><span class="p">,</span>
        <span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_sim</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Fillna(0) is needed in the cases where similarity_df does not have an entry for a pair of items.</span>
    <span class="c1"># e.g. i1 and i2 have never occurred together.</span>

    <span class="n">item_pair_sim</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">similarity_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">item_pair_sim</span><span class="p">[</span><span class="n">col_sim</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">item_pair_sim</span> <span class="o">=</span> <span class="n">item_pair_sim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">item_pair_sim</span><span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">item_pair_sim</span><span class="p">[</span><span class="s2">&quot;i2&quot;</span><span class="p">]</span>
    <span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df_intralist_similarity</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">item_pair_sim</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">col_user</span><span class="p">])</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="n">col_sim</span><span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">df_intralist_similarity</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="s2">&quot;avg_il_sim&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df_intralist_similarity</span>


<div class="viewcode-block" id="user_diversity"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.user_diversity">[docs]</a><span class="nd">@_check_column_dtypes_diversity_serendipity</span>
<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">user_diversity</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">reco_df</span><span class="p">,</span>
    <span class="n">item_feature_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
    <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
    <span class="n">col_relevance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate average diversity of recommendations for each user.</span>
<span class="sd">    The metric definition is based on formula (3) in the following reference:</span>

<span class="sd">    :Citation:</span>

<span class="sd">        Y.C. Zhang, D.Ó. Séaghdha, D. Quercia and T. Jambor, Auralist:</span>
<span class="sd">        introducing serendipity into music recommendation, WSDM 2012</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they have interacted with;</span>
<span class="sd">            contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item, col_relevance (optional).</span>
<span class="sd">            Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        item_feature_df (pandas.DataFrame): (Optional) It is required only when item_sim_measure=&#39;item_feature_vector&#39;.</span>
<span class="sd">            It contains two columns: col_item and features (a feature vector).</span>
<span class="sd">        item_sim_measure (str): (Optional) This column indicates which item similarity measure to be used.</span>
<span class="sd">            Available measures include item_cooccurrence_count (default choice) and item_feature_vector.</span>
<span class="sd">        col_item_features (str): item feature column name.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>
<span class="sd">        col_sim (str): This column indicates the column name for item similarity.</span>
<span class="sd">        col_relevance (str): This column indicates whether the recommended item is actually relevant to the user or not.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A dataframe with the following columns: col_user, user_diversity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_intralist_similarity</span> <span class="o">=</span> <span class="n">_get_intralist_similarity</span><span class="p">(</span>
        <span class="n">train_df</span><span class="p">,</span>
        <span class="n">reco_df</span><span class="p">,</span>
        <span class="n">item_feature_df</span><span class="p">,</span>
        <span class="n">item_sim_measure</span><span class="p">,</span>
        <span class="n">col_item_features</span><span class="p">,</span>
        <span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_sim</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">df_user_diversity</span> <span class="o">=</span> <span class="n">df_intralist_similarity</span>
    <span class="n">df_user_diversity</span><span class="p">[</span><span class="s2">&quot;user_diversity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">df_user_diversity</span><span class="p">[</span><span class="s2">&quot;avg_il_sim&quot;</span><span class="p">]</span>
    <span class="n">df_user_diversity</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_user_diversity</span><span class="p">[[</span><span class="n">col_user</span><span class="p">,</span> <span class="s2">&quot;user_diversity&quot;</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">col_user</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_user_diversity</span></div>


<div class="viewcode-block" id="diversity"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.diversity">[docs]</a><span class="nd">@_check_column_dtypes_diversity_serendipity</span>
<span class="k">def</span> <span class="nf">diversity</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">reco_df</span><span class="p">,</span>
    <span class="n">item_feature_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
    <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
    <span class="n">col_relevance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate average diversity of recommendations across all users.</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they have interacted with;</span>
<span class="sd">            contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item, col_relevance (optional).</span>
<span class="sd">            Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        item_feature_df (pandas.DataFrame): (Optional) It is required only when item_sim_measure=&#39;item_feature_vector&#39;.</span>
<span class="sd">            It contains two columns: col_item and features (a feature vector).</span>
<span class="sd">        item_sim_measure (str): (Optional) This column indicates which item similarity measure to be used.</span>
<span class="sd">            Available measures include item_cooccurrence_count (default choice) and item_feature_vector.</span>
<span class="sd">        col_item_features (str): item feature column name.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>
<span class="sd">        col_sim (str): This column indicates the column name for item similarity.</span>
<span class="sd">        col_relevance (str): This column indicates whether the recommended item is actually relevant to the user or not.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: diversity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df_user_diversity</span> <span class="o">=</span> <span class="n">user_diversity</span><span class="p">(</span>
        <span class="n">train_df</span><span class="p">,</span>
        <span class="n">reco_df</span><span class="p">,</span>
        <span class="n">item_feature_df</span><span class="p">,</span>
        <span class="n">item_sim_measure</span><span class="p">,</span>
        <span class="n">col_item_features</span><span class="p">,</span>
        <span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_sim</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">avg_diversity</span> <span class="o">=</span> <span class="n">df_user_diversity</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;user_diversity&quot;</span><span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">})[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">avg_diversity</span></div>


<span class="c1"># Novelty metrics</span>
<div class="viewcode-block" id="historical_item_novelty"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.historical_item_novelty">[docs]</a><span class="nd">@_check_column_dtypes_novelty_coverage</span>
<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">historical_item_novelty</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">reco_df</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate novelty for each item. Novelty is computed as the minus logarithm of</span>
<span class="sd">    (number of interactions with item / total number of interactions). The definition of the metric</span>
<span class="sd">    is based on the following reference using the choice model (eqs. 1 and 6):</span>

<span class="sd">    :Citation:</span>

<span class="sd">        P. Castells, S. Vargas, and J. Wang, Novelty and diversity metrics for recommender systems:</span>
<span class="sd">        choice, discovery and relevance, ECIR 2011</span>

<span class="sd">    The novelty of an item can be defined relative to a set of observed events on the set of all items.</span>
<span class="sd">    These can be events of user choice (item &quot;is picked&quot; by a random user) or user discovery</span>
<span class="sd">    (item &quot;is known&quot; to a random user). The above definition of novelty reflects a factor of item popularity.</span>
<span class="sd">    High novelty values correspond to long-tail items in the density function, that few users have interacted</span>
<span class="sd">    with and low novelty values correspond to popular head items.</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">                have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">                Interaction here follows the *item choice model* from Castells et al.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">                col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A dataframe with the following columns: col_item, item_novelty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_records</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">item_count</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">train_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">col_item</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()}</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">item_count</span><span class="p">[</span><span class="s2">&quot;item_novelty&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">item_count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_records</span><span class="p">)</span>
    <span class="n">df_item_novelty</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">item_count</span><span class="p">[[</span><span class="n">col_item</span><span class="p">,</span> <span class="s2">&quot;item_novelty&quot;</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">col_item</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_item_novelty</span></div>


<div class="viewcode-block" id="novelty"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.novelty">[docs]</a><span class="nd">@_check_column_dtypes_novelty_coverage</span>
<span class="k">def</span> <span class="nf">novelty</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="n">reco_df</span><span class="p">,</span> <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span> <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the average novelty in a list of recommended items (this assumes that the recommendation list</span>
<span class="sd">    is already computed). Follows section 5 from</span>

<span class="sd">    :Citation:</span>

<span class="sd">        P. Castells, S. Vargas, and J. Wang, Novelty and diversity metrics for recommender systems:</span>
<span class="sd">        choice, discovery and relevance, ECIR 2011</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">                have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">                Interaction here follows the *item choice model* from Castells et al.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">                col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: novelty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_item_novelty</span> <span class="o">=</span> <span class="n">historical_item_novelty</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="n">reco_df</span><span class="p">,</span> <span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">)</span>
    <span class="n">n_recommendations</span> <span class="o">=</span> <span class="n">reco_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reco_item_count</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">reco_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">col_item</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()}</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">reco_item_novelty</span> <span class="o">=</span> <span class="n">reco_item_count</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_item_novelty</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">col_item</span><span class="p">)</span>
    <span class="n">reco_item_novelty</span><span class="p">[</span><span class="s2">&quot;product&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">reco_item_novelty</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">reco_item_novelty</span><span class="p">[</span><span class="s2">&quot;item_novelty&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">avg_novelty</span> <span class="o">=</span> <span class="n">reco_item_novelty</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;product&quot;</span><span class="p">:</span> <span class="s2">&quot;sum&quot;</span><span class="p">})[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_recommendations</span>

    <span class="k">return</span> <span class="n">avg_novelty</span></div>


<span class="c1"># Serendipity metrics</span>
<div class="viewcode-block" id="user_item_serendipity"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.user_item_serendipity">[docs]</a><span class="nd">@_check_column_dtypes_diversity_serendipity</span>
<span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">user_item_serendipity</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">reco_df</span><span class="p">,</span>
    <span class="n">item_feature_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
    <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
    <span class="n">col_relevance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate serendipity of each item in the recommendations for each user.</span>
<span class="sd">    The metric definition is based on the following references:</span>

<span class="sd">    :Citation:</span>

<span class="sd">    Y.C. Zhang, D.Ó. Séaghdha, D. Quercia and T. Jambor, Auralist:</span>
<span class="sd">    introducing serendipity into music recommendation, WSDM 2012</span>

<span class="sd">    Eugene Yan, Serendipity: Accuracy’s unpopular best friend in Recommender Systems,</span>
<span class="sd">    eugeneyan.com, April 2020</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">              have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">              col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        item_feature_df (pandas.DataFrame): (Optional) It is required only when item_sim_measure=&#39;item_feature_vector&#39;.</span>
<span class="sd">            It contains two columns: col_item and features (a feature vector).</span>
<span class="sd">        item_sim_measure (str): (Optional) This column indicates which item similarity measure to be used.</span>
<span class="sd">            Available measures include item_cooccurrence_count (default choice) and item_feature_vector.</span>
<span class="sd">        col_item_features (str): item feature column name.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>
<span class="sd">        col_sim (str): This column indicates the column name for item similarity.</span>
<span class="sd">        col_relevance (str): This column indicates whether the recommended item is actually</span>
<span class="sd">              relevant to the user or not.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A dataframe with columns: col_user, col_item, user_item_serendipity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># for every col_user, col_item in reco_df, join all interacted items from train_df.</span>
    <span class="c1"># These interacted items are repeated for each item in reco_df for a specific user.</span>
    <span class="n">df_cosine_similarity</span> <span class="o">=</span> <span class="n">_get_cosine_similarity</span><span class="p">(</span>
        <span class="n">train_df</span><span class="p">,</span>
        <span class="n">item_feature_df</span><span class="p">,</span>
        <span class="n">item_sim_measure</span><span class="p">,</span>
        <span class="n">col_item_features</span><span class="p">,</span>
        <span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_sim</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">reco_user_item</span> <span class="o">=</span> <span class="n">reco_df</span><span class="p">[[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]]</span>
    <span class="n">reco_user_item</span><span class="p">[</span><span class="s2">&quot;reco_item_tmp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reco_user_item</span><span class="p">[</span><span class="n">col_item</span><span class="p">]</span>

    <span class="n">train_user_item</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]]</span>
    <span class="n">train_user_item</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="s2">&quot;train_item_tmp&quot;</span><span class="p">]</span>

    <span class="n">reco_train_user_item</span> <span class="o">=</span> <span class="n">reco_user_item</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">train_user_item</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">])</span>
    <span class="n">reco_train_user_item</span><span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reco_train_user_item</span><span class="p">[</span>
        <span class="p">[</span><span class="s2">&quot;reco_item_tmp&quot;</span><span class="p">,</span> <span class="s2">&quot;train_item_tmp&quot;</span><span class="p">]</span>
    <span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">reco_train_user_item</span><span class="p">[</span><span class="s2">&quot;i2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reco_train_user_item</span><span class="p">[</span>
        <span class="p">[</span><span class="s2">&quot;reco_item_tmp&quot;</span><span class="p">,</span> <span class="s2">&quot;train_item_tmp&quot;</span><span class="p">]</span>
    <span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">reco_train_user_item_sim</span> <span class="o">=</span> <span class="n">reco_train_user_item</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">df_cosine_similarity</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span>
    <span class="n">reco_train_user_item_sim</span><span class="p">[</span><span class="n">col_sim</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">reco_user_item_avg_sim</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">reco_train_user_item_sim</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">])</span>
        <span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="n">col_sim</span><span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">reco_user_item_avg_sim</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="p">,</span>
        <span class="s2">&quot;avg_item2interactedHistory_sim&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">df_user_item_serendipity</span> <span class="o">=</span> <span class="n">reco_user_item_avg_sim</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">reco_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">df_user_item_serendipity</span><span class="p">[</span><span class="s2">&quot;user_item_serendipity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span> <span class="o">-</span> <span class="n">df_user_item_serendipity</span><span class="p">[</span><span class="s2">&quot;avg_item2interactedHistory_sim&quot;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">df_user_item_serendipity</span><span class="p">[</span><span class="n">col_relevance</span><span class="p">]</span>
    <span class="n">df_user_item_serendipity</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_user_item_serendipity</span><span class="p">[[</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">,</span> <span class="s2">&quot;user_item_serendipity&quot;</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="n">col_user</span><span class="p">,</span> <span class="n">col_item</span><span class="p">])</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_user_item_serendipity</span></div>


<div class="viewcode-block" id="user_serendipity"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.user_serendipity">[docs]</a><span class="nd">@lru_cache_df</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nd">@_check_column_dtypes_diversity_serendipity</span>
<span class="k">def</span> <span class="nf">user_serendipity</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">reco_df</span><span class="p">,</span>
    <span class="n">item_feature_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
    <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
    <span class="n">col_relevance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate average serendipity for each user&#39;s recommendations.</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">              have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">              col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        item_feature_df (pandas.DataFrame): (Optional) It is required only when item_sim_measure=&#39;item_feature_vector&#39;.</span>
<span class="sd">            It contains two columns: col_item and features (a feature vector).</span>
<span class="sd">        item_sim_measure (str): (Optional) This column indicates which item similarity measure to be used.</span>
<span class="sd">            Available measures include item_cooccurrence_count (default choice) and item_feature_vector.</span>
<span class="sd">        col_item_features (str): item feature column name.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>
<span class="sd">        col_sim (str): This column indicates the column name for item similarity.</span>
<span class="sd">        col_relevance (str): This column indicates whether the recommended item is actually</span>
<span class="sd">              relevant to the user or not.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A dataframe with following columns: col_user, user_serendipity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df_user_item_serendipity</span> <span class="o">=</span> <span class="n">user_item_serendipity</span><span class="p">(</span>
        <span class="n">train_df</span><span class="p">,</span>
        <span class="n">reco_df</span><span class="p">,</span>
        <span class="n">item_feature_df</span><span class="p">,</span>
        <span class="n">item_sim_measure</span><span class="p">,</span>
        <span class="n">col_item_features</span><span class="p">,</span>
        <span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_sim</span><span class="p">,</span>
        <span class="n">col_relevance</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">df_user_serendipity</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_user_item_serendipity</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_user</span><span class="p">)</span>
        <span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;user_item_serendipity&quot;</span><span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">df_user_serendipity</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_user</span><span class="p">,</span> <span class="s2">&quot;user_serendipity&quot;</span><span class="p">]</span>
    <span class="n">df_user_serendipity</span> <span class="o">=</span> <span class="n">df_user_serendipity</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">col_user</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span>
        <span class="n">drop</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_user_serendipity</span></div>


<div class="viewcode-block" id="serendipity"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.serendipity">[docs]</a><span class="nd">@_check_column_dtypes_diversity_serendipity</span>
<span class="k">def</span> <span class="nf">serendipity</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span>
    <span class="n">reco_df</span><span class="p">,</span>
    <span class="n">item_feature_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">item_sim_measure</span><span class="o">=</span><span class="n">DEFAULT_ITEM_SIM_MEASURE</span><span class="p">,</span>
    <span class="n">col_item_features</span><span class="o">=</span><span class="n">DEFAULT_ITEM_FEATURES_COL</span><span class="p">,</span>
    <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span>
    <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span><span class="p">,</span>
    <span class="n">col_sim</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_COL</span><span class="p">,</span>
    <span class="n">col_relevance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate average serendipity for recommendations across all users.</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">              have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">              col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        item_feature_df (pandas.DataFrame): (Optional) It is required only when item_sim_measure=&#39;item_feature_vector&#39;.</span>
<span class="sd">            It contains two columns: col_item and features (a feature vector).</span>
<span class="sd">        item_sim_measure (str): (Optional) This column indicates which item similarity measure to be used.</span>
<span class="sd">            Available measures include item_cooccurrence_count (default choice) and item_feature_vector.</span>
<span class="sd">        col_item_features (str): item feature column name.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>
<span class="sd">        col_sim (str): This column indicates the column name for item similarity.</span>
<span class="sd">        col_relevance (str): This column indicates whether the recommended item is actually</span>
<span class="sd">              relevant to the user or not.</span>
<span class="sd">    Returns:</span>
<span class="sd">        float: serendipity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df_user_serendipity</span> <span class="o">=</span> <span class="n">user_serendipity</span><span class="p">(</span>
        <span class="n">train_df</span><span class="p">,</span>
        <span class="n">reco_df</span><span class="p">,</span>
        <span class="n">item_feature_df</span><span class="p">,</span>
        <span class="n">item_sim_measure</span><span class="p">,</span>
        <span class="n">col_item_features</span><span class="p">,</span>
        <span class="n">col_user</span><span class="p">,</span>
        <span class="n">col_item</span><span class="p">,</span>
        <span class="n">col_sim</span><span class="p">,</span>
        <span class="n">col_relevance</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">avg_serendipity</span> <span class="o">=</span> <span class="n">df_user_serendipity</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;user_serendipity&quot;</span><span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">})[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">avg_serendipity</span></div>


<span class="c1"># Coverage metrics</span>
<div class="viewcode-block" id="catalog_coverage"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.catalog_coverage">[docs]</a><span class="nd">@_check_column_dtypes_novelty_coverage</span>
<span class="k">def</span> <span class="nf">catalog_coverage</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span> <span class="n">reco_df</span><span class="p">,</span> <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span> <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate catalog coverage for recommendations across all users.</span>
<span class="sd">    The metric definition is based on the &quot;catalog coverage&quot; definition in the following reference:</span>

<span class="sd">    :Citation:</span>

<span class="sd">        G. Shani and A. Gunawardana, Evaluating Recommendation Systems,</span>
<span class="sd">        Recommender Systems Handbook pp. 257-297, 2010.</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">                have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">                Interaction here follows the *item choice model* from Castells et al.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">                col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: catalog coverage</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># distinct item count in reco_df</span>
    <span class="n">count_distinct_item_reco</span> <span class="o">=</span> <span class="n">reco_df</span><span class="p">[</span><span class="n">col_item</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
    <span class="c1"># distinct item count in train_df</span>
    <span class="n">count_distinct_item_train</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="n">col_item</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>

    <span class="c1"># catalog coverage</span>
    <span class="n">c_coverage</span> <span class="o">=</span> <span class="n">count_distinct_item_reco</span> <span class="o">/</span> <span class="n">count_distinct_item_train</span>
    <span class="k">return</span> <span class="n">c_coverage</span></div>


<div class="viewcode-block" id="distributional_coverage"><a class="viewcode-back" href="../../../source/evaluation.html#recommenders.evaluation.python_evaluation.distributional_coverage">[docs]</a><span class="nd">@_check_column_dtypes_novelty_coverage</span>
<span class="k">def</span> <span class="nf">distributional_coverage</span><span class="p">(</span>
    <span class="n">train_df</span><span class="p">,</span> <span class="n">reco_df</span><span class="p">,</span> <span class="n">col_user</span><span class="o">=</span><span class="n">DEFAULT_USER_COL</span><span class="p">,</span> <span class="n">col_item</span><span class="o">=</span><span class="n">DEFAULT_ITEM_COL</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate distributional coverage for recommendations across all users.</span>
<span class="sd">    The metric definition is based on formula (21) in the following reference:</span>

<span class="sd">    :Citation:</span>

<span class="sd">        G. Shani and A. Gunawardana, Evaluating Recommendation Systems,</span>
<span class="sd">        Recommender Systems Handbook pp. 257-297, 2010.</span>

<span class="sd">    Args:</span>
<span class="sd">        train_df (pandas.DataFrame): Data set with historical data for users and items they</span>
<span class="sd">                have interacted with; contains col_user, col_item. Assumed to not contain any duplicate rows.</span>
<span class="sd">                Interaction here follows the *item choice model* from Castells et al.</span>
<span class="sd">        reco_df (pandas.DataFrame): Recommender&#39;s prediction output, containing col_user, col_item,</span>
<span class="sd">                col_relevance (optional). Assumed to not contain any duplicate user-item pairs.</span>
<span class="sd">        col_user (str): User id column name.</span>
<span class="sd">        col_item (str): Item id column name.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: distributional coverage</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># In reco_df, how  many times each col_item is being recommended</span>
    <span class="n">df_itemcnt_reco</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">reco_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">col_item</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()}</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="c1"># the number of total recommendations</span>
    <span class="n">count_row_reco</span> <span class="o">=</span> <span class="n">reco_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">df_entropy</span> <span class="o">=</span> <span class="n">df_itemcnt_reco</span>
    <span class="n">df_entropy</span><span class="p">[</span><span class="s2">&quot;p(i)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_entropy</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">count_row_reco</span>
    <span class="n">df_entropy</span><span class="p">[</span><span class="s2">&quot;entropy(i)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_entropy</span><span class="p">[</span><span class="s2">&quot;p(i)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">df_entropy</span><span class="p">[</span><span class="s2">&quot;p(i)&quot;</span><span class="p">])</span>

    <span class="n">d_coverage</span> <span class="o">=</span> <span class="o">-</span><span class="n">df_entropy</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s2">&quot;entropy(i)&quot;</span><span class="p">:</span> <span class="s2">&quot;sum&quot;</span><span class="p">})[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">d_coverage</span></div>
</pre></div>

              </div>
              
        
            



<div class='prev-next-bottom'>
    

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By The Jupyter Book community<br/>
        
            &copy; Copyright 2021.<br/>
          <div class="extra_footer">
            Don't forget to check out <a href= https://arxiv.org/abs/2108.02899>our paper from Document Intelligence Workshop at KDD 2021!</a>
          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>